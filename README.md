# step_parser
Парсер формата STEP/STP на Python.

Использование: импортировать нужные функции, работать.

Функции, начинающиеся со знака подчёркивания, как правило, для самостоятельного использования не предназначены. Исключение — \_convert_string, которая может пригодиться в интерактивном режиме при анализе файла вручную.

При запуске файлов step_parser или assembly_tree_builder они вызывают функцию main для первого переданного в них аргумента и печатают результат. Например:
```
>python assembly_tree_builder.py Assembly1.stp
([[324, 325], [324, 325], [324, 326]],
 {324: "'Assembly1'", 325: "'Part1'", 326: "'Part2'"})
```

## step_parser
Функции разбора файла.

main(filename) — открывает и разбирает файл с переданным названием, поддерживает буквы из utf-8 в названиях сборок и подсборок (частично, тестировалось только для русского языка).
* Формат входных данных: строка с названием файла
* Формат выходных данных: как выходные данные у parse_stp.

parse_stp(data) — разбирает переданные данные.
* Формат входных данных: итерабельный объект (список, генератор, т.д.) со строками, представляющий stp-файл.
* Формат выходных данных: {10: ["operation", ["arg1", "arg2", "#3", ["arg4"] ...]], ...}
Пояснения и уточнения:
operation может быть любой строкой, описывающей операцию над аргументами. Если она пуста, то список аргументов — это список операций и имеет вид: [["op1", ["arg1", "arg2", ...]], ["op2", ["arg3", "arg4", ...]], ...].
Список аргументов может быть пустым или может содержать строки, ссылки на другие элементы и вложенные списки в любом порядке, количестве и вложенности. Ссылки на другие элементы имеют тип строк и выглядят как "#123", где 123 — номер элемента, на который ссылаются.

string_replacer(parsed_data) — заменяет коды символов utf-8 на эти символы в строках (тестировалось только на буквах русского языка).
* Формат входных данных: как выходные данные у parse_stp.
* Формат выходных данных: как выходные данные у parse_stp, но с заменёнными символами.

reference_replacer(parsed_data) — заменяет ссылки на элементы содержимым этих элементов.
* Формат входных данных: как выходные данные у parse_stp.
* Формат выходных данных: как выходные данные у parse_stp, но ссылки заменены на содержимое словаря по этим ссылкам. Пример:
До:
```
{10: ["test1", ["arg1", "#11"]],
 11: ["test2", ["arg2"]]}
```
После:
```
{10: ["test1", ["arg1", ["test2", ["arg2"]]]],
 11: ["test2", ["arg2"]]}
```
Уточнения:
Ссылки заменяются не на сам словарь, а на ссылку на него, так что полученное дерево не требует так много памяти, как может показаться. Также, если два элемента прямо или косвенно ссылаются друг на друга, то образуются вложенные списки бесконечной вложенности; их обработка возложена на того, кто будет работать с деревом (хотя в формате STP такое вроде не встречается).

## assembly_tree_builder
Функции построения дерева модели.

main(filename) — разбирает файл и строит дерево сборки.
* Входные данные: строка, имя файла.
* Выходные данные: как у build_tree.

build_tree(parsed_data) — строит дерево сборки, показывающее, какие в сборке есть модели и подсборки.
* Входные данные: как выходные данные у parse_stp.\
* Выходные данные: (assembly_relationships, names), где:
assembly_relationships — список списков по два элемента , обозначающий взаимосвязи между элементами: первый элемент в паре является родительским по отношению к вложенному в него второму.
names — словарь названий сборок, подсборок и элементов.
Пример:
`([[1768, 1769], ...], {1768:"Сборка1", ...})`
